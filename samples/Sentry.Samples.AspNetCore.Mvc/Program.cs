using System.Net;
using Samples.AspNetCore.Mvc;
using Sentry.AspNetCore;
using Sentry.Extensibility;

var builder = WebApplication.CreateBuilder(args);

// Example integration with advanced configuration scenarios. The 'options' parameter is populated through the
// configuration system, which includes anything defined on the ConfigurationBuilder ('appsettings.json', environment
// variables etc.)
// See: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-8.0
builder.WebHost.UseSentry(options =>
    {
        // Tracks the release which sent the event and enables more features: https://docs.sentry.io/learn/releases/
        // If not explicitly set here, the SDK attempts to read it from: AssemblyInformationalVersionAttribute and AssemblyVersion
        // TeamCity: %build.vcs.number%, VSTS: BUILD_SOURCEVERSION, Travis-CI: TRAVIS_COMMIT, AppVeyor: APPVEYOR_REPO_COMMIT, CircleCI: CIRCLE_SHA1
        options.Release = "e386dfd"; // Could also be any format, such as: 2.0.1 or whatever you use to version your app

        options.MaxBreadcrumbs = 200;

        // Set a proxy for outgoing HTTP connections
        options.HttpProxy = null; // new WebProxy("https://localhost:3128");

        // Example: Disabling support to compressed responses:
        options.DecompressionMethods = DecompressionMethods.None;

        // Call GET /home/block/true to see this in action
        options.CaptureBlockingCalls = true;

        options.MaxQueueItems = 100;
        options.ShutdownTimeout = TimeSpan.FromSeconds(5);

        options.TracesSampleRate = 1.0; // For production, you may want to lower this to stay inside your quota

        // In addition to (or instead of) setting the TracesSampleRate to a fixed value, you can also define a function
        // that calculates the sample rate dynamically based on the current context.
        options.TracesSampler = ctx =>
        {
            // In distributed tracing scenarios, we may want to respect upstream sampling decisions... for example, if
            // the javascript frontend contains tracing instrumentation, a decision not to sample this request may
            // already have been made. In that case, we don't want to sample this request since it would result in an
            // incomplete trace.
            if (ctx.TransactionContext.IsParentSampled == false)
            {
                // If the parent transaction is not sampled, don't sample this one either
                return 0.0;
            }

            // Only sample 30% of the requests to this /home/sampler route
            var httpPath = ctx.TryGetHttpPath();
            if (string.Equals(httpPath, "/home/sampler", StringComparison.OrdinalIgnoreCase))
            {
                return 0.3;
            }

            // For all other routes, use the statically configured sample rate. Returning null here would achieve the
            // same thing (if the TraceSampler function returns null, the SDK falls back to the TracesSampleRate)
            return options.TracesSampleRate;
        };

        // Configures the root scope
        options.ConfigureScope(s => s.SetTag("Always sent", "this tag"));
    });

// Register as many ISentryEventExceptionProcessor as you need. They ALL get called.
builder.Services.AddSingleton<ISentryEventExceptionProcessor, SpecialExceptionProcessor>();

// You can also register as many ISentryEventProcessor as you need.
builder.Services.AddTransient<ISentryEventProcessor, ExampleEventProcessor>();

builder.Services.AddSentryTunneling();

// Everything after this is just the boilerplate code generated by dotnet new mvc

builder.Services.AddControllersWithViews();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();

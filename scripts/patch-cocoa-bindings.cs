#:package Microsoft.CodeAnalysis.CSharp@4.10.0
#:package Microsoft.CodeAnalysis.CSharp.Workspaces@4.10.0

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CodeFormatter = Microsoft.CodeAnalysis.Formatting.Formatter;

if (args.Length != 1)
{
    Console.Error.WriteLine("Usage: patch-cocoa-bindings.cs <path/to/ApiDefinitions.cs>");
    return;
}

const string Header = @"// -----------------------------------------------------------------------------
// This file is auto-generated by Objective Sharpie and patched via the script
// at /scripts/patch-cocoa-bindings.cs.  Do not edit this file directly.
// If changes are required, update the script instead.
// -----------------------------------------------------------------------------

";
var code = Header + File.ReadAllText(args[0]);

// Fix broken multi-line comments
code = Regex.Replace(code, @"(DEPRECATED_MSG_ATTRIBUTE\()\n\s*", "$1");
code = Regex.Replace(code, @"(DEPRECATED_MSG_ATTRIBUTE\([^)]*?)""\s*\r?\n\s*""", "$1 ");

var tree = CSharpSyntaxTree.ParseText(code);
var nodes = tree.GetCompilationUnitRoot()
    .WithNamespace("Sentry.CocoaSdk")
    .RemoveClass("CFunctions")
    // Make enums, interfaces, and delegates internal
    .AsInternal("Sentry*", "internal")
    .WithAttribute("*Sentry*", "Internal")
    // Adjust protocols (some are models)
    .VerifyModel("SentryRedactOptions")
    .VerifyModel("SentrySerializable")
    .VerifyModel("SentrySpan")
    .RemoveComment("SentryRRWebEvent", "[Model]")
    .RemoveComment("SentryReplayBreadcrumbConverter", "[Model]")
    .RemoveComment("SentryViewScreenshotProvider", "[Model]")
    // Adjust base types
    .WithAttribute("SentrySpan", "BaseType (typeof(NSObject))")
    .WithAttribute("SentryRedactOptions", "BaseType (typeof(NSObject))")
    // Remove INSCopying due to https://github.com/xamarin/xamarin-macios/issues/17130
    .RemoveBaseType("INSCopying")
    // Fix property-to-method conversions
    .PropertyToMethod("Sentry*", "Serialize")
    .PropertyToMethod("SentrySpan", "ToTraceHeader")
    .PropertyToMethod("SentryTraceContext", "ToBaggage")
    .PropertyToMethod("PrivateSentrySDKOnly", "Capture*")
    // Verify the rest
    .VerifyProperty("*Sentry*", "*", "MethodToProperty") // TODO: replace broad patterns with one-by-one verification
    .VerifyProperty("SentryOptions", "*Targets", "StronglyTypedNSArray")
    // Fix delegate argument names
    .RenameParameter("NSError", "arg*", "error")
    .RenameParameter("NSHttpUrlResponse", "arg*", "response")
    .RenameParameter("SentryEvent", "arg*", "@event")
    .RenameParameter("SentrySamplingContext", "arg*", "samplingContext")
    .RenameParameter("SentryBreadcrumb", "arg*", "breadcrumb")
    .RenameParameter("SentrySpan", "arg*", "span")
    .RenameParameter("SentryLog", "arg*", "log")
    .RenameParameter("SentryProfileOptions", "arg*", "options")
    // Fix interface names
    .RenameInterface("ISentrySerializable", "SentrySerializable")
    .RenameInterface("ISentryRedactOptions", "SentryRedactOptions")
    .RenameBaseType("ISentrySerializable", "SentrySerializable")
    .RenameBaseType("ISentryRedactOptions", "SentryRedactOptions")
    // Rename conflicting SentryRRWebEvent (protocol vs. interface)
    .RenameProtocol("SentryRRWebEvent", "ISentryRRWebEvent")
    // Adjust nullable return delegates (though broken until this is fixed: https://github.com/xamarin/xamarin-macios/issues/17109)
    .WithAttribute("SentryBeforeBreadcrumbCallback", "return: NullAllowed")
    .WithAttribute("SentryBeforeSendEventCallback", "return: NullAllowed")
    .WithAttribute("SentryTracesSamplerCallback", "return: NullAllowed")
    // Fix nullable return attributes
    .RemoveAttribute("PrivateSentrySDKOnly", "Capture*", "NullAllowed")
    .WithAttribute("PrivateSentrySDKOnly", "CaptureScreenshots", "return: NullAllowed")
    .WithAttribute("PrivateSentrySDKOnly", "CaptureViewHierarchies", "return: NullAllowed")
    // For PrivateApiDefinitions.cs
    .WithModifier("SentryScope", "partial")
    // error CS0246: The type or namespace name 'iOS' could not be found
    .RemoveAttribute("iOS")
    // error CS0246: The type or namespace name 'Mac' could not be found
    .RemoveAttribute("Mac")
    // error CS0117: 'PlatformName' does not contain a definition for 'iOSAppExtension'
    .RemoveAttribute("Unavailable")
    // error CS0114: 'SentryXxx.IsEqual(NSObject?)' hides inherited member 'NSObject.IsEqual(NSObject?)'.
    .RemoveMethod("Sentry*", "IsEqual")
    // error CS0246: The type or namespace name '_NSZone' could not be found
    .RemoveMethod("Sentry*", "CopyWithZone")
    // SentryEnvelope* is not whitelisted
    .RemoveMethod("PrivateSentrySDKOnly", "CaptureEnvelope")
    .RemoveMethod("PrivateSentrySDKOnly", "EnvelopeWithData")
    .RemoveMethod("PrivateSentrySDKOnly", "StoreEnvelope")
    // SentryLoggerDelegate and SentryCurrentDateProvider are not whitelisted
    .RemoveMethod("SentryLogger", "Constructor")
    // SentryAppStartMeasurement is not whitelisted
    .RemoveDelegate("SentryOnAppStartMeasurementAvailable")
    // unused
    .RemoveDelegate("SentryUserFeedbackConfigurationBlock")
    // error CS0114: 'SentryXxx.Description' hides inherited member 'NSObject.Description'.
    .RemoveProperty("Sentry*", "Description")
    // SentryAppStartMeasurement is not whitelisted
    .RemoveProperty("PrivateSentrySDKOnly", "*AppStartMeasurement*")
    // Minimize SentryDependencyContainer
    .RemoveMethod("SentryDependencyContainer", "*")
    .KeepProperties("SentryDependencyContainer", "SharedInstance", "DebugImageProvider")
    // SentryUserFeedbackConfiguration is not whitelisted
    .RemoveProperty("SentryOptions", "ConfigureUserFeedback")
    .RemoveProperty("SentryOptions", "UserFeedbackConfiguration")
    .KeepInterfaces(
        "ISentryRRWebEvent",
        "PrivateSentrySDKOnly",
        "SentryAttachment",
        "SentryBaggage",
        "SentryBreadcrumb",
        "SentryClient",
        "SentryDebugImageProvider",
        "SentryDebugMeta",
        "SentryDependencyContainer",
        "SentryDsn",
        "SentryEvent",
        "SentryException",
        "SentryExperimentalOptions",
        "SentryFeedback",
        "SentryFeedbackAPI",
        "SentryFrame",
        "SentryGeo",
        "SentryHttpStatusCodeRange",
        "SentryHub",
        "SentryId",
        "SentryLog",
        "SentryLogAttribute",
        "SentryLogger",
        "SentryMeasurementUnit",
        "SentryMeasurementUnitDuration",
        "SentryMeasurementUnitFraction",
        "SentryMeasurementUnitInformation",
        "SentryMechanism",
        "SentryMechanismContext",
        "SentryMechanismMeta",
        "SentryMessage",
        "SentryNSError",
        "SentryOptions",
        "SentryProfileOptions",
        "SentryRedactOptions",
        "SentryReplayApi",
        "SentryReplayBreadcrumbConverter",
        "SentryReplayOptions",
        "SentryRequest",
        "SentryRRWebEvent",
        "SentrySamplingContext",
        "SentryScope",
        "SentryScreenFrames",
        "SentrySDK",
        "SentrySerializable",
        "SentrySpan",
        "SentrySpanContext",
        "SentrySpanId",
        "SentryStacktrace",
        "SentryThread",
        "SentryTraceContext",
        "SentryTraceHeader",
        "SentryTransactionContext",
        "SentryUser",
        "SentryViewScreenshotOptions",
        "SentryViewScreenshotProvider"
    )
    // Rename and retarget the experimental options property
    .RenameProperty("SentryOptions", "_swiftExperimentalOptions", "Experimental")
    .ChangePropertyType("SentryOptions", "Experimental", "SentryExperimentalOptions")
    // error CS0311: The type 'SentryXxx' cannot be used as type parameter 'TValue' in the generic type or method 'NSDictionary<TKey, TValue>'.
    .ChangeGenericTypeArgument("NSDictionary", "Sentry*", "NSObject");

var formatted = CodeFormatter.Format(nodes, new AdhocWorkspace());
File.WriteAllText(args[0], formatted.ToFullString() + "\n");

internal static class FilterExtensions
{
    public static CompilationUnitSyntax KeepInterfaces(
        this CompilationUnitSyntax root,
        params string[] names)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => !names.Any(name => node.Identifier.Matches(name)));
        return root.RemoveNodes(nodes, SyntaxRemoveOptions.KeepNoTrivia)!;
    }

    public static CompilationUnitSyntax WithNamespace(
        this CompilationUnitSyntax root,
        string name)
    {
        var node = SyntaxFactory.FileScopedNamespaceDeclaration(SyntaxFactory.ParseName(name));
        return SyntaxFactory.CompilationUnit()
            .WithUsings(root.Usings)
            .AddMembers(node.WithMembers(root.Members));
    }

    private static CompilationUnitSyntax RemoveByPredicate<T>(
        this CompilationUnitSyntax root,
        Func<T, bool> predicate) where T : SyntaxNode
    {
        var nodes = root.DescendantNodes()
            .OfType<T>()
            .Where(node => predicate(node));
        return root.RemoveNodes(nodes, SyntaxRemoveOptions.KeepNoTrivia)!;
    }

    public static CompilationUnitSyntax RemoveClass(
        this CompilationUnitSyntax root,
        string name)
    {
        return root.RemoveByPredicate<ClassDeclarationSyntax>(node => node.Identifier.Matches(name));
    }

    public static CompilationUnitSyntax RemoveDelegate(
        this CompilationUnitSyntax root,
        string name)
    {
        return root.RemoveByPredicate<DelegateDeclarationSyntax>(node => node.Identifier.Matches(name));
    }

    public static CompilationUnitSyntax RemoveAttribute(
        this CompilationUnitSyntax root,
        string name)
    {
        return root
            .RemoveByPredicate<AttributeSyntax>(node => node.Name.Matches(name))
            .RemoveByPredicate<AttributeListSyntax>(node => node.Attributes.Count == 0);
    }

    public static CompilationUnitSyntax RemoveAttribute(
        this CompilationUnitSyntax root,
        string type,
        string name,
        string attribute)
    {
        return root.RemoveByPredicate<AttributeSyntax>(node =>
            node.Name.Matches(attribute) &&
            node.Parent?.Parent is MethodDeclarationSyntax method &&
            method.Identifier.Matches(name) &&
            method.HasParent(type));
    }

    public static CompilationUnitSyntax RemoveBaseType(
        this CompilationUnitSyntax root,
        string name)
    {
        return root
            .RemoveByPredicate<BaseTypeSyntax>(node => node.Type.Matches(name))
            .RemoveByPredicate<BaseListSyntax>(node => node.Types.Count == 0);
    }

    public static CompilationUnitSyntax RemoveMethod(
        this CompilationUnitSyntax root,
        string type,
        string name)
    {
        return root.RemoveByPredicate<MethodDeclarationSyntax>(node => node.Identifier.Matches(name) && node.HasParent(type));
    }

    public static CompilationUnitSyntax KeepMethods(
        this CompilationUnitSyntax root,
        string type,
        params string[] names)
    {
        return root.RemoveByPredicate<MethodDeclarationSyntax>(node => !names.Any(name => node.Identifier.Matches(name)) && node.HasParent(type));
    }

    public static CompilationUnitSyntax RemoveProperty(
        this CompilationUnitSyntax root,
        string type,
        string name)
    {
        return root.RemoveByPredicate<PropertyDeclarationSyntax>(node => node.Identifier.Matches(name) && node.HasParent(type));
    }

    public static CompilationUnitSyntax KeepProperties(
        this CompilationUnitSyntax root,
        string type,
        params string[] names)
    {
        return root.RemoveByPredicate<PropertyDeclarationSyntax>(node => !names.Any(name => node.Identifier.Matches(name)) && node.HasParent(type));
    }

    public static CompilationUnitSyntax WithAttribute(
        this CompilationUnitSyntax root,
        string type,
        string attribute)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(type) && !node.HasAttribute(attribute))
            .Cast<SyntaxNode>()
            .Concat(root.DescendantNodes()
                .OfType<DelegateDeclarationSyntax>()
                .Where(node => node.Identifier.Matches(type) && !node.HasAttribute(attribute)));
        return root.ReplaceNodes(nodes, (node, _) => node.WithAttribute(attribute));
    }

    public static CompilationUnitSyntax WithAttribute(
        this CompilationUnitSyntax root,
        string type,
        string name,
        string attribute)
    {
        var nodes = root.DescendantNodes()
            .OfType<MethodDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(name) && node.HasParent(type) && !node.HasAttribute(attribute));
        return root.ReplaceNodes(nodes, (node, _) => node.WithAttribute(attribute));
    }

    public static CompilationUnitSyntax AsInternal(
        this CompilationUnitSyntax root,
        string name,
        string modifier)
    {
        var nodes = root.DescendantNodes()
            .OfType<EnumDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(name));
        return root.ReplaceNodes(nodes, (node, _) => node.WithModifier(modifier));
    }

    public static CompilationUnitSyntax WithModifier(
        this CompilationUnitSyntax root,
        string name,
        string modifier)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(name));
        return root.ReplaceNodes(nodes, (node, _) => node.WithModifier(modifier));
    }

    public static CompilationUnitSyntax VerifyModel(
        this CompilationUnitSyntax root,
        string name)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(name) && node.HasAttribute("Protocol"));
        return root.ReplaceNodes(nodes, (node, _) => node.WithAttribute("Model").RemoveComment("[Model]"));
    }

    public static CompilationUnitSyntax RemoveComment(
        this CompilationUnitSyntax root,
        string name,
        string comment)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(name) && node.HasComment(comment));
        return root.ReplaceNodes(nodes, (node, _) => node.RemoveComment(comment));
    }

    public static CompilationUnitSyntax RenameBaseType(
        this CompilationUnitSyntax root,
        string from,
        string to)
    {
        var nodes = root.DescendantNodes()
            .OfType<BaseTypeSyntax>()
            .Where(node => node.Type.Matches(from));
        return root.ReplaceNodes(nodes, (node, _) => node.WithType(SyntaxFactory.ParseTypeName(to)));
    }

    public static CompilationUnitSyntax RenameInterface(
        this CompilationUnitSyntax root,
        string from,
        string to)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(from));
        return root.ReplaceNodes(nodes, (node, _) => node.WithIdentifier(SyntaxFactory.Identifier(to)));
    }

    public static CompilationUnitSyntax RenameProtocol(
        this CompilationUnitSyntax root,
        string from,
        string to)
    {
        var nodes = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(from) && node.HasAttribute("Protocol"));
        return root.ReplaceNodes(nodes, (node, _) => node.WithIdentifier(SyntaxFactory.Identifier(to)));
    }

    public static CompilationUnitSyntax RenameParameter(
        this CompilationUnitSyntax root,
        string type,
        string from,
        string to)
    {
        var nodes = root.DescendantNodes()
            .OfType<ParameterSyntax>()
            .Where(node => node.Identifier.Matches(from) && node.Type?.Matches(type) == true);
        return root.ReplaceNodes(nodes, (node, _) => node.WithIdentifier(SyntaxFactory.Identifier(to)));
    }

    public static CompilationUnitSyntax PropertyToMethod(
        this CompilationUnitSyntax root,
        string type,
        string name)
    {
        var nodes = root.DescendantNodes()
            .OfType<PropertyDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(name) && node.HasParent(type) && node.HasAttribute("Verify", "MethodToProperty"));
        return root.ReplaceNodes(nodes, (node, _) =>
        {
            var attributes = node.AttributeLists.RemoveAttribute("Verify", "MethodToProperty");
            return SyntaxFactory.MethodDeclaration(node.Type, SyntaxFactory.Identifier(node.Identifier.Text))
                .WithModifiers(node.Modifiers)
                .WithAttributeLists(attributes)
                .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        });
    }

    public static CompilationUnitSyntax VerifyProperty(
        this CompilationUnitSyntax root,
        string type,
        string property,
        string verify)
    {
        var nodes = root.DescendantNodes()
            .OfType<PropertyDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(property) && node.HasParent(type));
        return root.ReplaceNodes(nodes, (node, _) => node.WithAttributeLists(node.AttributeLists.RemoveAttribute("Verify", verify)));
    }

    public static CompilationUnitSyntax RenameProperty(
        this CompilationUnitSyntax root,
        string type,
        string from,
        string to)
    {
        var nodes = root.DescendantNodes()
            .OfType<PropertyDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(from) && node.HasParent(type));
        return root.ReplaceNodes(nodes, (node, _) => node.WithIdentifier(SyntaxFactory.Identifier(to)));
    }

    public static CompilationUnitSyntax ChangePropertyType(
        this CompilationUnitSyntax root,
        string type,
        string property,
        string newType)
    {
        var nodes = root.DescendantNodes()
            .OfType<PropertyDeclarationSyntax>()
            .Where(node => node.Identifier.Matches(property) && node.HasParent(type));
        return root.ReplaceNodes(nodes, (node, _) => node.WithType(SyntaxFactory.ParseTypeName(newType)));
    }

    public static CompilationUnitSyntax ChangeGenericTypeArgument(
        this CompilationUnitSyntax root,
        string type,
        string from,
        string to)
    {
        var nodes = root.DescendantNodes()
            .OfType<GenericNameSyntax>()
            .Where(node => node.Identifier.Matches(type) && node.TypeArgumentList.Arguments.Any(arg => arg.Matches(from)));

        return root.ReplaceNodes(nodes, (node, _) =>
        {
            var args = node.TypeArgumentList.Arguments.Select(arg => arg.Matches(from) ? SyntaxFactory.ParseTypeName(to) : arg);
            return node.WithTypeArgumentList(node.TypeArgumentList.WithArguments(SyntaxFactory.SeparatedList(args)));
        });
    }
}

internal static class SyntaxNodeExtensions
{
    public static bool HasParent(this SyntaxNode node, string name)
    {
        return node.Parent is TypeDeclarationSyntax parent && parent.Identifier.Matches(name);
    }

    public static bool HasAttribute(this SyntaxNode node, string attribute, string? arguments = null)
    {
        return node.GetAttributes()
            .SelectMany(al => al.Attributes)
            .Any(attr => attr.Name.Matches(attribute) && (arguments == null || attr.ArgumentList?.Arguments.ToString().Contains(arguments) == true));
    }

    public static SyntaxList<AttributeListSyntax> GetAttributes(this SyntaxNode node)
    {
        return node switch
        {
            BaseTypeDeclarationSyntax type => type.AttributeLists,
            DelegateDeclarationSyntax del => del.AttributeLists,
            MethodDeclarationSyntax method => method.AttributeLists,
            PropertyDeclarationSyntax property => property.AttributeLists,
            _ => throw new NotSupportedException(node.GetType().Name)
        };
    }

    public static SyntaxNode WithAttribute(this SyntaxNode node, string attribute)
    {
        var attributes = SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Attribute(SyntaxFactory.IdentifierName(attribute))));
        var existingAttributes = node.GetAttributes();
        var add = new Func<SyntaxNode, AttributeListSyntax, SyntaxNode>((n, attr) => n switch
        {
            BaseTypeDeclarationSyntax type => type.AddAttributeLists(attr),
            DelegateDeclarationSyntax del => del.AddAttributeLists(attr),
            MethodDeclarationSyntax method => method.AddAttributeLists(attr),
            PropertyDeclarationSyntax property => property.AddAttributeLists(attr),
            _ => throw new NotSupportedException(n.GetType().Name)
        });

        if (existingAttributes.Count > 0)
        {
            return add(node, attributes);
        }

        return add(node.WithLeadingTrivia(SyntaxFactory.TriviaList()), attributes.WithLeadingTrivia(node.GetLeadingTrivia()));
    }

    public static SyntaxNode WithModifier(this SyntaxNode node, string modifier)
    {
        var modifiers = SyntaxFactory.TokenList(SyntaxFactory.ParseToken(modifier));
        return node switch
        {
            InterfaceDeclarationSyntax iface => iface.WithModifiers(modifiers),
            EnumDeclarationSyntax enm => enm.WithModifiers(modifiers),
            _ => throw new NotSupportedException(node.GetType().Name)
        };
    }

    public static bool HasComment(this SyntaxNode node, string comment)
    {
        var trivia = node.GetLeadingTrivia();
        return trivia.Any(t =>
            t.IsKind(SyntaxKind.MultiLineCommentTrivia) &&
            t.ToString().Contains(comment));
    }

    public static SyntaxNode RemoveComment(this SyntaxNode node, string comment)
    {
        var trivia = SyntaxFactory.TriviaList(
            node.GetLeadingTrivia().Where(t =>
                !(t.IsKind(SyntaxKind.MultiLineCommentTrivia) && t.ToString().Contains(comment))));
        return node.WithLeadingTrivia(trivia);
    }
}

internal static class AttributeListExtensions
{
    public static SyntaxList<AttributeListSyntax> RemoveAttribute(this SyntaxList<AttributeListSyntax> lists, string attribute, string? arguments = null)
    {
        var attributes = lists
            .Select(al => al.WithAttributes(
                SyntaxFactory.SeparatedList(al.Attributes.Where(attr => !(attr.Name.ToString() == attribute && (arguments == null || attr.ArgumentList?.Arguments.ToString().Contains(arguments) == true))))
            ))
            .Where(al => al.Attributes.Count > 0);
        return SyntaxFactory.List(attributes);
    }
}

internal static class WildcardExtensions
{
    public static bool Matches(this NameSyntax syntax, string pattern)
    {
        return syntax.ToString().Matches(pattern);
    }

    public static bool Matches(this TypeSyntax syntax, string pattern)
    {
        return syntax.ToString().Matches(pattern);
    }

    public static bool Matches(this SyntaxToken token, string pattern)
    {
        return token.Text.Matches(pattern);
    }

    public static bool Matches(this string str, string pattern)
    {
        var negate = pattern.StartsWith('!');
        var actual = pattern.TrimStart('!');
        if (actual == str)
        {
            return !negate;
        }

        if (!actual.Contains('*') && !actual.Contains('?'))
        {
            return negate;
        }

        var regex = Regex.Escape(actual).Replace("\\*", ".*").Replace("\\?", ".");
        return Regex.IsMatch(str, $"^{regex}$") != negate;
    }
}

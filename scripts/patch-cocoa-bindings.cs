#:package Microsoft.CodeAnalysis.CSharp@4.10.0
#:package Microsoft.CodeAnalysis.CSharp.Workspaces@4.10.0

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CodeFormatter = Microsoft.CodeAnalysis.Formatting.Formatter;

if (args.Length != 1)
{
    Console.Error.WriteLine("Usage: patch-cocoa-bindings.cs <path/to/ApiDefinitions.cs>");
    return;
}

const string Header = @"// -----------------------------------------------------------------------------
// This file is auto-generated by Objective Sharpie and patched via the script
// at /scripts/patch-cocoa-bindings.cs.  Do not edit this file directly.
// If changes are required, update the script instead.
// -----------------------------------------------------------------------------

";
var code = Header + File.ReadAllText(args[0]);

// Fix broken multi-line comments
code = Regex.Replace(code, @"(DEPRECATED_MSG_ATTRIBUTE\()\n\s*", "$1");
code = Regex.Replace(code, @"(DEPRECATED_MSG_ATTRIBUTE\([^)]*?)""\s*\r?\n\s*""", "$1 ");

var tree = CSharpSyntaxTree.ParseText(code);
var nodes = tree.GetCompilationUnitRoot()
    .Namespace("Sentry.CocoaSdk")
    // Remove CFunctions class
    .Blacklist<ClassDeclarationSyntax>("CFunctions")
    // Make enums, interfaces, and delegates internal
    .Access<EnumDeclarationSyntax>("Sentry*", SyntaxKind.InternalKeyword)
    .Attribute<InterfaceDeclarationSyntax>("*Sentry*", "Internal")
    .Attribute<DelegateDeclarationSyntax>("Sentry*", "Internal")
    // Adjust protocols (some are models)
    .Model("SentryRedactOptions")
    .Model("SentrySerializable")
    .Model("SentrySpan")
    .Model("SentryRRWebEvent", false)
    .Model("SentryReplayBreadcrumbConverter", false)
    .Model("SentryViewScreenshotProvider", false)
    // Adjust base types
    .BaseType("SentrySpan", "NSObject")
    .BaseType("SentryRedactOptions", "NSObject")
    // Remove INSCopying due to https://github.com/xamarin/xamarin-macios/issues/17130
    .Blacklist<BaseTypeSyntax>("INSCopying")
    .Blacklist<BaseListSyntax>("")
    // Fix property-to-method conversions
    .PropertyToMethod("Sentry*.Serialize")
    .PropertyToMethod("SentrySpan.ToTraceHeader")
    .PropertyToMethod("SentryTraceContext.ToBaggage")
    .PropertyToMethod("PrivateSentrySDKOnly.Capture*")
    // Verify
    .Verify<PropertyDeclarationSyntax>("*Sentry*.*", "MethodToProperty") // TODO: replace broad pattern with one-by-one verification
    .Verify<PropertyDeclarationSyntax>("SentryOptions.*Targets", "StronglyTypedNSArray")
    // Fix delegate argument names
    .Rename<ParameterSyntax>("NSError arg*", "NSError error")
    .Rename<ParameterSyntax>("NSHttpUrlResponse arg*", "NSHttpUrlResponse response")
    .Rename<ParameterSyntax>("SentryEvent arg*", "SentryEvent @event")
    .Rename<ParameterSyntax>("SentrySamplingContext arg*", "SentrySamplingContext samplingContext")
    .Rename<ParameterSyntax>("SentryBreadcrumb arg*", "SentryBreadcrumb breadcrumb")
    .Rename<ParameterSyntax>("SentrySpan arg*", "SentrySpan span")
    .Rename<ParameterSyntax>("SentryLog arg*", "SentryLog log")
    .Rename<ParameterSyntax>("SentryProfileOptions arg*", "SentryProfileOptions options")
    // Fix interface names
    .Rename<InterfaceDeclarationSyntax>("SentrySerializable", "ISentrySerializable")
    .Rename<InterfaceDeclarationSyntax>("SentryRedactOptions", "ISentryRedactOptions")
    .Rename<ParameterSyntax>("SentryRedactOptions options", "ISentryRedactOptions options")
    // Rename conflicting SentryRRWebEvent (protocol vs. interface)
    .Rename<InterfaceDeclarationSyntax>("SentryRRWebEvent", "ISentryRRWebEvent", iface => iface.HasAttribute("Protocol"))
    // Adjust nullable return delegates (though broken until this is fixed: https://github.com/xamarin/xamarin-macios/issues/17109)
    .Attribute<DelegateDeclarationSyntax>("SentryBeforeBreadcrumbCallback", "return: NullAllowed")
    .Attribute<DelegateDeclarationSyntax>("SentryBeforeSendEventCallback", "return: NullAllowed")
    .Attribute<DelegateDeclarationSyntax>("SentryTracesSamplerCallback", "return: NullAllowed")
    .Partial("SentryScope")
    .Blacklist<AttributeSyntax>(
        // error CS0246: The type or namespace name 'iOS' could not be found
        "iOS",
        // error CS0246: The type or namespace name 'Mac' could not be found
        "Mac",
        // error CS0117: 'PlatformName' does not contain a definition for 'iOSAppExtension'
        "Unavailable"
    )
    .Blacklist<AttributeListSyntax>("")
    .Blacklist<MethodDeclarationSyntax>(
        // error CS0114: 'SentryXxx.IsEqual(NSObject?)' hides inherited member 'NSObject.IsEqual(NSObject?)'.
        "Sentry*.IsEqual",
        // error CS0246: The type or namespace name '_NSZone' could not be found
        "Sentry*.CopyWithZone",
        // SentryEnvelope* is not whitelisted
        "PrivateSentrySDKOnly.CaptureEnvelope",
        "PrivateSentrySDKOnly.EnvelopeWithData",
        "PrivateSentrySDKOnly.StoreEnvelope",
        // deprecated
        "Sentry*.CaptureUserFeedback"
    )
    .Blacklist<DelegateDeclarationSyntax>(
        // SentryAppStartMeasurement is not whitelisted
        "SentryOnAppStartMeasurementAvailable",
        // deprecated
        "SentryUserFeedbackConfigurationBlock"
    )
    .Blacklist<PropertyDeclarationSyntax>(
        // error CS0114: 'SentryXxx.Description' hides inherited member 'NSObject.Description'.
        "Sentry*.Description",
        // SentryAppStartMeasurement is not whitelisted
        "PrivateSentrySDKOnly.*AppStartMeasurement*",
        // SentryStructuredLogAttribute is not whitelisted
        "SentryLog.Attributes",
        // deprecated
        "SentryOptions.ConfigureUserFeedback"
    )
    .Whitelist<InterfaceDeclarationSyntax>(
        "ISentryRedactOptions",
        "ISentryRRWebEvent",
        "ISentrySerializable",
        "PrivateSentrySDKOnly",
        "SentryAttachment",
        "SentryBaggage",
        "SentryBreadcrumb",
        "SentryClient",
        "SentryDebugImageProvider",
        "SentryDebugMeta",
        "SentryDsn",
        "SentryEvent",
        "SentryException",
        "SentryFeedback",
        "SentryFeedbackAPI",
        "SentryFrame",
        "SentryGeo",
        "SentryHttpStatusCodeRange",
        "SentryHub",
        "SentryId",
        "SentryLog",
        "SentryLogger",
        "SentryMeasurementUnit",
        "SentryMeasurementUnitDuration",
        "SentryMeasurementUnitFraction",
        "SentryMeasurementUnitInformation",
        "SentryMechanism",
        "SentryMechanismMeta",
        "SentryMessage",
        "SentryNSError",
        "SentryOptions",
        "SentryProfileOptions",
        "SentryRedactOptions",
        "SentryReplayApi",
        "SentryReplayBreadcrumbConverter",
        "SentryReplayOptions",
        "SentryRequest",
        "SentryRRWebEvent",
        "SentrySamplingContext",
        "SentryScope",
        "SentryScreenFrames",
        "SentrySDK",
        "SentrySession",
        "SentrySpan",
        "SentrySpanContext",
        "SentrySpanId",
        "SentryStacktrace",
        "SentryThread",
        "SentryTraceContext",
        "SentryTraceHeader",
        "SentryTransactionContext",
        "SentryUser",
        "SentryViewScreenshotOptions",
        "SentryViewScreenshotProvider"
    );

var formatted = CodeFormatter.Format(nodes, new AdhocWorkspace());
File.WriteAllText(args[0], formatted.ToFullString());

internal static class FilterExtensions
{
    public static CompilationUnitSyntax Blacklist<T>(
        this CompilationUnitSyntax root,
        params string[] names) where T : SyntaxNode
    {
        var nodesToRemove = root.DescendantNodes()
            .OfType<T>()
            .Where(node => names.Any(node.Matches));
        return root.RemoveNodes(nodesToRemove, SyntaxRemoveOptions.KeepNoTrivia)!;
    }

    public static CompilationUnitSyntax Whitelist<T>(
        this CompilationUnitSyntax root,
        params string[] names) where T : SyntaxNode
    {
        var nodesToRemove = root.DescendantNodes()
            .OfType<T>()
            .Where(node => !names.Any(node.Matches));
        return root.RemoveNodes(nodesToRemove, SyntaxRemoveOptions.KeepNoTrivia)!;
    }

    public static CompilationUnitSyntax Namespace(
        this CompilationUnitSyntax root,
        string name)
    {
        var namespaceDeclaration = SyntaxFactory.FileScopedNamespaceDeclaration(SyntaxFactory.ParseName(name))
            .WithNamespaceKeyword(SyntaxFactory.Token(SyntaxKind.NamespaceKeyword)
                .WithLeadingTrivia(SyntaxFactory.EndOfLine("\n"))
                .WithTrailingTrivia(SyntaxFactory.Space))
            .WithTrailingTrivia(SyntaxFactory.EndOfLine("\n"));
        return SyntaxFactory.CompilationUnit()
            .WithUsings(root.Usings)
            .AddMembers(namespaceDeclaration.WithMembers(root.Members));
    }

    public static CompilationUnitSyntax Attribute<T>(
        this CompilationUnitSyntax root,
        string typeName,
        string attributeName) where T : SyntaxNode
    {
        var nodesToUpdate = root.DescendantNodes()
            .OfType<T>()
            .Where(node => node.Matches(typeName))
            .Where(node => !node.HasAttribute(attributeName))
            .ToList();

        var attribute = SyntaxFactory.Attribute(SyntaxFactory.IdentifierName(attributeName));
        var attributeList = SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(attribute));

        var replacements = nodesToUpdate.ToDictionary(
            node => node,
            node => node.WithAttribute(attributeList));

        return root.ReplaceNodes(replacements.Keys, (orig, _) => replacements[orig]);
    }

    public static CompilationUnitSyntax Model(
        this CompilationUnitSyntax root,
        string name,
        bool isModel = true)
    {
        var iface = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .Where(node => node.Matches(name))
            .Where(node => node.HasAttribute("Protocol"))
            .FirstOrDefault();

        if (iface == null)
        {
            return root;
        }

        var trivia = SyntaxFactory.TriviaList(
            iface.GetLeadingTrivia().Where(t =>
                !(t.IsKind(SyntaxKind.MultiLineCommentTrivia) && t.ToString().Contains("[Model]"))));
        var result = root.ReplaceNode(iface, iface.WithLeadingTrivia(trivia));
        return isModel
            ? result.Attribute<InterfaceDeclarationSyntax>(name, "Model")
            : result;
    }

    public static CompilationUnitSyntax BaseType(
        this CompilationUnitSyntax root,
        string name,
        string baseType)
    {
        return root.Attribute<InterfaceDeclarationSyntax>(name, $"BaseType (typeof({baseType}))");
    }

    public static CompilationUnitSyntax Rename<T>(
        this CompilationUnitSyntax root,
        string oldName,
        string newName,
        Func<T, bool>? predicate = null) where T : SyntaxNode
    {
        var replacements = new Dictionary<SyntaxNode, SyntaxNode>();
        foreach (var node in root.DescendantNodes().OfType<T>())
        {
            if (predicate != null && !predicate(node))
            {
                continue;
            }

            if (node.Matches(oldName))
            {
                replacements[node] = node.WithIdentifier(newName);
            }
        }
        return root.ReplaceNodes(replacements.Keys, (orig, _) => replacements[orig]);
    }

    public static CompilationUnitSyntax Partial(
        this CompilationUnitSyntax root,
        string name)
    {
        var iface = root.DescendantNodes()
            .OfType<InterfaceDeclarationSyntax>()
            .FirstOrDefault(i => i.Matches(name));

        if (iface == null)
        {
            return root;
        }

        return root.ReplaceNode(
            iface,
            iface.AddModifiers(SyntaxFactory.Token(SyntaxKind.PartialKeyword).WithTrailingTrivia(SyntaxFactory.Space))
        );
    }

    public static CompilationUnitSyntax PropertyToMethod(this CompilationUnitSyntax root, string pattern)
    {
        var properties = root.DescendantNodes()
            .OfType<PropertyDeclarationSyntax>()
            .Where(prop =>
                prop.AttributeLists.SelectMany(a => a.Attributes)
                    .Any(attr => attr.Name.ToString() == "Verify" && attr.ArgumentList?.Arguments.ToString().Contains("MethodToProperty") == true) &&
                prop.AccessorList != null &&
                prop.AccessorList.Accessors.Count == 1 &&
                prop.AccessorList.Accessors[0].Kind() == SyntaxKind.GetAccessorDeclaration &&
                prop.GetQualifiedName().Matches(pattern)
            );

        return root.ReplaceNodes(properties, (original, _) =>
        {
            var newAttributes = SyntaxFactory.List(
                original.AttributeLists
                    .Select(al => al.WithAttributes(
                        SyntaxFactory.SeparatedList(
                            al.Attributes.Where(attr =>
                                !(attr.Name.ToString() == "Verify" && attr.ArgumentList?.Arguments.ToString().Contains("MethodToProperty") == true)
                            )
                        )
                    ))
                    .Where(al => al.Attributes.Count > 0)
            );

            return SyntaxFactory.MethodDeclaration(original.Type, SyntaxFactory.Identifier(original.Identifier.Text))
                .WithModifiers(original.Modifiers)
                .WithAttributeLists(newAttributes)
                .WithParameterList(SyntaxFactory.ParameterList())
                .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken))
                .WithLeadingTrivia(original.GetLeadingTrivia())
                .WithTrailingTrivia(original.GetTrailingTrivia());
        });
    }

    public static CompilationUnitSyntax Verify<T>(
        this CompilationUnitSyntax root,
        string typeName,
        string verify) where T : MemberDeclarationSyntax
    {
        return root.ReplaceNodes(
            root.DescendantNodes().OfType<T>().Where(node => node.Matches(typeName)),
            (original, _) =>
            {
                var newAttrLists = original.AttributeLists
                    .Select(al => al.WithAttributes(
                        SyntaxFactory.SeparatedList(
                            al.Attributes.Where(attr =>
                                !(attr.Name.ToString() == "Verify" &&
                                  attr.ArgumentList != null &&
                                  attr.ArgumentList.Arguments.ToString().Matches(verify))
                            )
                        )
                    ))
                    .Where(al => al.Attributes.Count > 0);

                return original.WithAttributeLists(SyntaxFactory.List(newAttrLists));
            });
    }

    public static CompilationUnitSyntax Access<T>(
        this CompilationUnitSyntax root,
        string name,
        SyntaxKind modifier) where T : MemberDeclarationSyntax
    {
        var nodes = root.DescendantNodes().OfType<T>()
            .Where(node => node.Matches(name));

        return root.ReplaceNodes(nodes, (original, _) =>
            original.WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(modifier)))
        );
    }
}

internal static class SyntaxNodeExtensions
{
    public static string GetIdentifier(this SyntaxNode node)
    {
        return node switch
        {
            TypeDeclarationSyntax type => type.Identifier.Text,
            EnumDeclarationSyntax type => type.Identifier.Text,
            DelegateDeclarationSyntax del => del.Identifier.Text,
            MethodDeclarationSyntax method => method.Identifier.Text,
            PropertyDeclarationSyntax property => property.Identifier.Text,
            ParameterSyntax param => $"{param.Type} {param.Identifier.Text}",
            AttributeSyntax attr => attr.Name.ToString(),
            AttributeListSyntax list => string.Join(",", list.Attributes.Select(a => a.Name.ToString())),
            BaseTypeSyntax type => type.Type.ToString(),
            BaseListSyntax list => string.Join(",", list.Types.Select(t => t.Type.ToString())),
            FileScopedNamespaceDeclarationSyntax ns => ns.Name.ToString(),
            NamespaceDeclarationSyntax ns => ns.Name.ToString(),
            _ => throw new NotSupportedException(node.GetType().Name)
        };
    }

    public static SyntaxNode WithIdentifier(this SyntaxNode node, string newName)
    {
        if (node is ParameterSyntax param)
        {
            var parts = newName.Trim().Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
            var newType = parts.Length > 1 ? parts[0] : param.Type?.ToString();
            var newParamName = parts.Length > 1 ? parts[1] : parts[0];

            var updated = param;
            if (newType != null && newType != param.Type?.ToString())
            {
                updated = updated.WithType(SyntaxFactory.ParseTypeName(newType));
            }
            if (newParamName != param.Identifier.Text)
            {
                updated = updated.WithIdentifier(SyntaxFactory.Identifier(newParamName));
            }
            return updated;
        }

        var newIdentifier = SyntaxFactory.Identifier(newName);
        return node switch
        {
            InterfaceDeclarationSyntax iface => iface.WithIdentifier(newIdentifier),
            ClassDeclarationSyntax cls => cls.WithIdentifier(newIdentifier),
            StructDeclarationSyntax str => str.WithIdentifier(newIdentifier),
            EnumDeclarationSyntax enm => enm.WithIdentifier(newIdentifier),
            DelegateDeclarationSyntax del => del.WithIdentifier(newIdentifier),
            MethodDeclarationSyntax method => method.WithIdentifier(newIdentifier),
            PropertyDeclarationSyntax property => property.WithIdentifier(newIdentifier),
            _ => throw new NotSupportedException(node.GetType().Name)
        };
    }

    public static SyntaxNode WithAttribute(this SyntaxNode node, AttributeListSyntax attributeList)
    {
        var existingAttributes = node switch
        {
            InterfaceDeclarationSyntax iface => iface.AttributeLists,
            ClassDeclarationSyntax cls => cls.AttributeLists,
            StructDeclarationSyntax str => str.AttributeLists,
            EnumDeclarationSyntax enm => enm.AttributeLists,
            DelegateDeclarationSyntax del => del.AttributeLists,
            MethodDeclarationSyntax method => method.AttributeLists,
            PropertyDeclarationSyntax property => property.AttributeLists,
            _ => throw new NotSupportedException(node.GetType().Name)
        };

        if (existingAttributes.Count > 0)
        {
            var listWithTrivia = attributeList.WithTrailingTrivia(SyntaxFactory.EndOfLine("\n"));
            return node switch
            {
                InterfaceDeclarationSyntax iface => iface.AddAttributeLists(listWithTrivia),
                ClassDeclarationSyntax cls => cls.AddAttributeLists(listWithTrivia),
                StructDeclarationSyntax str => str.AddAttributeLists(listWithTrivia),
                EnumDeclarationSyntax enm => enm.AddAttributeLists(listWithTrivia),
                DelegateDeclarationSyntax del => del.AddAttributeLists(listWithTrivia),
                MethodDeclarationSyntax method => method.AddAttributeLists(listWithTrivia),
                PropertyDeclarationSyntax property => property.AddAttributeLists(listWithTrivia),
                _ => throw new NotSupportedException(node.GetType().Name)
            };
        }
        else
        {
            var listWithTrivia = attributeList
                .WithLeadingTrivia(node.GetLeadingTrivia())
                .WithTrailingTrivia(SyntaxFactory.EndOfLine("\n"));

            var nodeWithoutLeadingTrivia = node.WithLeadingTrivia(SyntaxFactory.TriviaList());

            return nodeWithoutLeadingTrivia switch
            {
                InterfaceDeclarationSyntax iface => iface.AddAttributeLists(listWithTrivia),
                ClassDeclarationSyntax cls => cls.AddAttributeLists(listWithTrivia),
                StructDeclarationSyntax str => str.AddAttributeLists(listWithTrivia),
                EnumDeclarationSyntax enm => enm.AddAttributeLists(listWithTrivia),
                DelegateDeclarationSyntax del => del.AddAttributeLists(listWithTrivia),
                MethodDeclarationSyntax method => method.AddAttributeLists(listWithTrivia),
                PropertyDeclarationSyntax property => property.AddAttributeLists(listWithTrivia),
                _ => throw new NotSupportedException(node.GetType().Name)
            };
        }
    }

    public static string GetQualifiedName(this SyntaxNode node)
    {
        var identifier = node.GetIdentifier();
        var parent = node.Parent;
        while (parent != null)
        {
            if (parent is TypeDeclarationSyntax typeDecl)
            {
                return $"{typeDecl.Identifier.Text}.{identifier}";
            }
            parent = parent.Parent;
        }
        return identifier;
    }

    public static bool Matches(this SyntaxNode node, string pattern)
    {
        var actualPattern = pattern.TrimStart('!');
        if (node.GetIdentifier().Matches(actualPattern) || node.GetQualifiedName().Matches(actualPattern))
        {
            return !pattern.StartsWith('!');
        }
        return false;
    }

    public static bool HasAttribute(this SyntaxNode node, string attributeName)
    {
        return node switch
        {
            InterfaceDeclarationSyntax iface => iface.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString() == attributeName),
            ClassDeclarationSyntax cls => cls.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString() == attributeName),
            StructDeclarationSyntax str => str.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString() == attributeName),
            EnumDeclarationSyntax enm => enm.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString() == attributeName),
            MethodDeclarationSyntax method => method.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString() == attributeName),
            PropertyDeclarationSyntax property => property.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(attr => attr.Name.ToString() == attributeName),
            _ => false
        };
    }
}

internal static class StringExtensions
{
    public static bool Matches(this string str, string pattern)
    {
        if (pattern == str)
        {
            return true;
        }

        if (!pattern.Contains('*') && !pattern.Contains('?'))
        {
            return false;
        }

        var regex = Regex.Escape(pattern).Replace("\\*", ".*").Replace("\\?", ".");
        return Regex.IsMatch(str, $"^{regex}$");
    }

    public static string TabsToSpaces(this string str, int spacesPerTab = 4)
    {
        return str.Replace("\t", new string(' ', spacesPerTab));
    }
}
